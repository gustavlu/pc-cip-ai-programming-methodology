# AI Programming Methodology: Prompt-Centric Causal Invariant Programming (PC-CIP)

> **PC-CIP** is a modern **AI programming methodology** designed specifically for **prompt-based software development with large language models (LLMs)**.
>
> It provides a structured, auditable, and invariant-driven approach to building software *with* AI, rather than merely *using* AI as a code generator.

---

## Keywords (SEO)
AI programming methodology, AI-driven software development, prompt-based programming, LLM programming methodology, AI software engineering, invariant-driven development, causality-based programming, programming with AI, prompt engineering methodology

---

## Why an AI Programming Methodology Is Needed

Most existing programming methodologies were designed for **human-written code**:
- Object-Oriented Programming
- Functional Programming
- Agile / Clean Architecture

However, **AI-assisted programming** introduces new challenges:
- Hallucinated behavior
- Implicit assumptions
- Hidden side effects
- Poor traceability from prompt → code

**PC-CIP** solves this by making **prompts the primary programming artifact** and enforcing correctness through **invariants, causality, and failure modeling**.

---

## Core Idea

> Software should be defined by **what must never break**, not by how it is implemented.

PC-CIP focuses on:
- Explicit invariants
- Explicit causality
- Explicit failure behavior
- Explicit acceptance tests

The AI is treated as a **compiler constrained by contracts**, not a creative author.

---

## Core Principles

### 1. Invariants Over Implementation
Programs are specified by properties that must always hold, regardless of refactoring, scaling, or rewrites.

### 2. Explicit Causality
Every computation declares:
- What triggers it
- What effects are allowed
- What effects are forbidden

### 3. Failure Is a First-Class State
Failure behavior is mandatory, defined up front, and testable.

### 4. Prompts Are Source Code
Prompts are structured, versioned, and reviewable.

---

## The Spec Block (Core Unit)

The **Spec Block** is the foundational artifact in PC-CIP.

```text
[PC-CIP SPEC BLOCK v1]

GOAL
- Desired outcome

CONTEXT
- Runtime, deployment, constraints

INTERFACES
- Inputs, outputs, schemas

HARD INVARIANTS
- Must always hold

SOFT GOALS
- Optimizations, prioritized

CAUSALITY MAP
- Triggers
- Commands
- Allowed effects
- Forbidden effects

FAILURE POLICY
- Defaults, retries, idempotency

OBSERVABILITY
- Logs, metrics, audits

ACCEPTANCE TESTS
- Minimal proof of correctness

NON-GOALS
- Explicit exclusions
```

---

## Hard Invariants vs Soft Goals

### Hard Invariants
Non-negotiable correctness constraints:
- No duplicate charges
- No unauthorized access
- No plaintext secrets

Each invariant must map to:
- Enforcement
- Test
- Monitoring

### Soft Goals
Optimizations that may trade off:
- Performance
- Readability
- Dependency minimization

---

## Causality Map

The causality map prevents AI from inventing behavior.

```text
Trigger: HTTP POST /checkout
Command: CreateOrder
Allowed Effects: DB.insert, Payment.authorize
Forbidden Effects: Email.send
Invariant: No duplicate charge
```

---

## AI Safety Rails

- **Assumption Budget**: max 3 explicit assumptions
- **Diff Discipline**: changes via patches or file lists
- **Stop Conditions**: AI must halt on ambiguity

---

## PC-CIP Workflow

1. Contract Summary
2. Design Skeleton
3. Implementation Plan
4. Code + Tests
5. Proof Pack (Invariant → Enforcement → Test → Monitoring)

---

## Getting Started (Quick)

1. Write a Spec Block
2. Validate AI understanding (no code)
3. Review Design Skeleton
4. Approve Implementation Plan
5. Generate Code + Proof Pack

---

## Change Management

All changes use **Change Blocks** to ensure minimal diffs and invariant preservation.

---

## Common Failure Modes

- Vague invariants
- Missing forbidden effects
- Undefined failure behavior
- No proof pack

---

## Design Philosophy

Humans think in procedures.  
Systems fail on invariants.

PC-CIP aligns software development with how AI systems reason: **constraints first, execution second**.

---

## AI Model Attribution

This documentation was generated by **ChatGPT using the GPT-5.2 model**.

---

## Status

Experimental by design.  
Fork, adapt, stress-test, and evolve.
